#include "GameEngine.h"
#include "Camera.h"
#include "LightingShaders.h"
#include "OBJLoader.h"
#include <glad/glad.h>
#include <iostream>

// Variables globales pour la souris
float lastX = 640.0f;
float lastY = 360.0f;
bool firstMouse = true;
FPSCamera* g_camera = nullptr;

void mouse_callback(GLFWwindow* window, double xpos, double ypos) {
    (void)window;
    
    if (firstMouse) {
        lastX = static_cast<float>(xpos);
        lastY = static_cast<float>(ypos);
        firstMouse = false;
    }

    float xoffset = static_cast<float>(xpos) - lastX;
    float yoffset = lastY - static_cast<float>(ypos);

    lastX = static_cast<float>(xpos);
    lastY = static_cast<float>(ypos);

    if (g_camera) {
        g_camera->ProcessMouseMovement(xoffset, yoffset);
    }
}

// ============================================
// MedicalSimulator - Visualiseur anatomique 3D
// ============================================
class MedicalSimulator : public GameEngine {
public:
    void Init() override {
        std::cout << "=== Medical Anatomy Visualizer ===" << std::endl;

        GameEngine::Init();

        // Configuration souris
        glfwSetInputMode(GetRenderer().GetWindow(), GLFW_CURSOR, GLFW_CURSOR_DISABLED);
        glfwSetCursorPosCallback(GetRenderer().GetWindow(), mouse_callback);

        // Caméra
        m_Camera = FPSCamera(glm::vec3(0.0f, 0.0f, 5.0f));
        g_camera = &m_Camera;

        // Shaders avec éclairage
        m_Shader = new Shader(lightingVertexShader, lightingFragmentShader);

        // Créer un modèle de cœur (sphère pour le moment)
        // Tu pourras remplacer par un vrai modèle .obj de cœur plus tard
        m_HeartModel = MeshGenerator::CreateSphere(1.0f, 36, 18);

        std::cout << "\n=== Controls ===" << std::endl;
        std::cout << "WASD - Move camera" << std::endl;
        std::cout << "Mouse - Look around" << std::endl;
        std::cout << "Space/Shift - Up/Down" << std::endl;
        std::cout << "1 - Red color (arterial)" << std::endl;
        std::cout << "2 - Blue color (venous)" << std::endl;
        std::cout << "ESC - Exit" << std::endl;
        std::cout << "\n=== Simulator initialized! ===" << std::endl;
    }

    void ProcessInput(double deltaTime) override {
        auto window = GetRenderer().GetWindow();
        float dt = static_cast<float>(deltaTime);

        if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS) {
            GetRenderer().SetShouldClose(true);
        }

        // Déplacement
        if (glfwGetKey(window, GLFW_KEY_W) == GLFW_PRESS)
            m_Camera.ProcessKeyboard(FORWARD, dt);
        if (glfwGetKey(window, GLFW_KEY_S) == GLFW_PRESS)
            m_Camera.ProcessKeyboard(BACKWARD, dt);
        if (glfwGetKey(window, GLFW_KEY_A) == GLFW_PRESS)
            m_Camera.ProcessKeyboard(LEFT, dt);
        if (glfwGetKey(window, GLFW_KEY_D) == GLFW_PRESS)
            m_Camera.ProcessKeyboard(RIGHT, dt);
        if (glfwGetKey(window, GLFW_KEY_SPACE) == GLFW_PRESS)
            m_Camera.ProcessKeyboard(UP, dt);
        if (glfwGetKey(window, GLFW_KEY_LEFT_SHIFT) == GLFW_PRESS)
            m_Camera.ProcessKeyboard(DOWN, dt);

        // Changer la couleur (simulation artère/veine)
        if (glfwGetKey(window, GLFW_KEY_1) == GLFW_PRESS) {
            m_ObjectColor = glm::vec3(0.8f, 0.1f, 0.1f); // Rouge (artère)
            std::cout << "Mode: Arterial blood (red)" << std::endl;
        }
        if (glfwGetKey(window, GLFW_KEY_2) == GLFW_PRESS) {
            m_ObjectColor = glm::vec3(0.1f, 0.1f, 0.8f); // Bleu (veine)
            std::cout << "Mode: Venous blood (blue)" << std::endl;
        }
    }

    void Update(double deltaTime) override {
        // Animation de battement de cœur (pulsation)
        m_HeartBeatTime += static_cast<float>(deltaTime);
        float beat = 1.0f + 0.1f * sinf(m_HeartBeatTime * 2.0f); // Pulsation à 2Hz
        m_HeartScale = beat;
    }

    void Render() override {
        m_Shader->Use();

        // Lumière
        glm::vec3 lightPos(3.0f, 3.0f, 3.0f);
        glm::vec3 lightColor(1.0f, 1.0f, 1.0f);

        m_Shader->SetVec3("objectColor", m_ObjectColor);
        m_Shader->SetVec3("lightPos", lightPos);
        m_Shader->SetVec3("viewPos", m_Camera.Position);
        m_Shader->SetVec3("lightColor", lightColor);

        // Matrices
        glm::mat4 model = glm::mat4(1.0f);
        model = glm::scale(model, glm::vec3(m_HeartScale));
        
        glm::mat4 view = m_Camera.GetViewMatrix();
        glm::mat4 projection = glm::perspective(
            glm::radians(m_Camera.Zoom),
            (float)GetRenderer().GetWidth() / (float)GetRenderer().GetHeight(),
            0.1f,
            100.0f
        );

        m_Shader->SetMat4("model", model);
        m_Shader->SetMat4("view", view);
        m_Shader->SetMat4("projection", projection);

        // Dessiner le modèle
        m_HeartModel.Draw();
    }

    void Cleanup() override {
        std::cout << "=== Cleaning up Medical Simulator ===" << std::endl;
        
        m_HeartModel.Cleanup();
        delete m_Shader;
        g_camera = nullptr;
        
        GameEngine::Cleanup();
    }

private:
    Shader* m_Shader = nullptr;
    FPSCamera m_Camera;
    MeshData m_HeartModel;
    
    glm::vec3 m_ObjectColor = glm::vec3(0.8f, 0.1f, 0.1f); // Rouge par défaut
    float m_HeartBeatTime = 0.0f;
    float m_HeartScale = 1.0f;
};

// ============================================
// Point d'entrée
// ============================================
int main() {
    try {
        MedicalSimulator simulator;
        simulator.Init();
        simulator.Run();
    }
    catch (const std::exception& e) {
        std::cerr << "Error: " << e.what() << std::endl;
        return 1;
    }

    return 0;
}